import * as _pandacss_types from '@pandacss/types';
import { PandaHookable, Artifact, ConfigResultWithHooks, Runtime as Runtime$1, ParserResultType, Config } from '@pandacss/types';
import { Generator } from '@pandacss/generator';
import { Project } from '@pandacss/parser';
import { Runtime } from '@pandacss/types/src/runtime';
import { Root, Message } from 'postcss';

declare const getChunkEngine: ({ paths, config, runtime: { path, fs }, }: Generator & {
    runtime: Runtime;
    hooks: PandaHookable;
}) => {
    dir: string;
    readFile(file: string): string;
    getFiles(): string[];
    format(file: string): string;
    getArtifact(file: string, css: string): Artifact;
    rm(file: string): void;
    empty(): void;
    readonly glob: string[];
};

declare const getOutputEngine: ({ paths, runtime: { path, fs }, }: Generator & {
    runtime: Runtime;
    hooks: PandaHookable;
}) => {
    empty(): void;
    write(output: Artifact | undefined): Promise<PromiseSettledResult<void>[] | undefined>;
};

declare const createContext: (conf: ConfigResultWithHooks) => PandaContext;
type PandaContext = Generator & {
    runtime: Runtime$1;
    hooks: PandaHookable;
    project: Project;
    getFiles: () => string[];
    chunks: ReturnType<typeof getChunkEngine>;
    output: ReturnType<typeof getOutputEngine>;
};

type Options = {
    onResult?: (file: string, result: ParserResultType) => void;
};
declare function analyzeTokens(ctx: PandaContext, options?: Options): {
    duration: {
        extractTimeByFiles: {
            [k: string]: number;
        };
        extractTotal: number;
        classify: number;
    };
    fileSizes: {
        lineCount: number;
        normal: string | number | any[] | {
            value: any;
            symbol: any;
            exponent: number;
            unit: string;
        };
        minified: string | number | any[] | {
            value: any;
            symbol: any;
            exponent: number;
            unit: string;
        };
        gzip: {
            normal: string | number | any[] | {
                value: any;
                symbol: any;
                exponent: number;
                unit: string;
            };
            minified: string | number | any[] | {
                value: any;
                symbol: any;
                exponent: number;
                unit: string;
            };
        };
    };
} & {
    counts: {
        filesWithTokens: number;
        propNameUsed: number;
        tokenUsed: number;
        shorthandUsed: number;
        propertyPathUsed: number;
        typeUsed: number;
        instanceNameUsed: number;
        kindUsed: number;
        instanceOfKindUsed: number;
        colorsUsed: number;
    };
    stats: {
        filesWithMostInstance: {
            [k: string]: number;
        };
        filesWithMostPropValueCombinations: {
            [k: string]: number;
        };
        mostUseds: {
            propNames: {
                key: string;
                count: number;
            }[];
            tokens: {
                key: string;
                count: number;
            }[];
            shorthands: {
                key: string;
                count: number;
            }[];
            conditions: {
                key: string;
                count: number;
            }[];
            propertyPaths: {
                key: string;
                count: number;
            }[];
            categories: {
                key: string;
                count: number;
            }[];
            types: {
                key: string;
                count: number;
            }[];
            instanceNames: {
                key: string;
                count: number;
            }[];
            fromKinds: {
                key: string;
                count: number;
            }[];
            instanceOfKinds: {
                key: string;
                count: number;
            }[];
            colors: {
                key: string;
                count: number;
            }[];
        };
    };
    details: {
        byId: Map<number, _pandacss_types.ReportItem>;
        byInstanceId: Map<number, _pandacss_types.ReportInstanceItem>;
        byFilepath: Map<string, Set<number>>;
        byInstanceInFilepath: Map<string, Set<number>>;
        globalMaps: {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        };
        byFilePathMaps: Map<string, {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        }>;
    };
};
declare const writeAnalyzeJSON: (fileName: string, result: ReturnType<typeof analyzeTokens>, ctx: PandaContext) => Promise<void>;

type ConfigDepsResult = {
    modifiedMap: Map<string, number>;
    isModified: boolean;
};
declare class Builder {
    /**
     * The current panda context
     */
    context: PandaContext | undefined;
    configDependencies: Set<string>;
    writeFileCss: (file: string, css: string) => void;
    checkConfigDeps: (configPath: string, deps: Set<string>) => ConfigDepsResult;
    getConfigPath: () => string;
    setup: (options?: {
        configPath?: string;
        cwd?: string;
    }) => Promise<void>;
    setupContext: (options: {
        configPath: string;
        depsModifiedMap: Map<string, number>;
    }) => Promise<void>;
    getContextOrThrow: () => PandaContext;
    get fileModifiedMap(): Map<string, number>;
    get fileCssMap(): Map<string, string>;
    extractFile: (ctx: PandaContext, file: string) => Promise<string | undefined>;
    extract: () => Promise<void>;
    toString: () => string;
    isValidRoot: (root: Root) => boolean;
    write: (root: Root) => void;
    registerDependency: (fn: (dep: Message) => void) => void;
}

declare function findConfig(): string | undefined;
declare function loadConfigAndCreateContext(options?: {
    cwd?: string;
    config?: Config;
    configPath?: string;
}): Promise<PandaContext>;

declare function debugFiles(ctx: PandaContext, options: {
    outdir: string;
    dry: boolean;
}): Promise<void>;

declare function execCommand(cmd: string, cwd: string): Promise<void>;

/**
 * Parse a file and return the corresponding css
 */
declare function extractFile(ctx: PandaContext, file: string): string | undefined;
declare function emitArtifacts(ctx: PandaContext): Promise<{
    box: string;
    msg: string;
}>;
declare function emitArtfifactsAndCssChunks(ctx: PandaContext): Promise<{
    files: string[];
    msg: string;
}>;
/**
 * Writes all the css chunks in outdir/chunks/{file}.css
 * and bundles them in outdir/styles.css
 */
declare function writeAndBundleCssChunks(ctx: PandaContext): Promise<{
    files: string[];
    msg: string;
}>;
/**
 * Bundles all the included files CSS into the given outfile
 * Including the root CSS artifact files content (global, static, reset, tokens, keyframes)
 * Without any imports
 */
declare function bundleCss(ctx: PandaContext, outfile: string): Promise<{
    files: string[];
    msg: string;
}>;
/**
 * Bundles all the files CSS into outdir/chunks/{file}.css
 * Without writing any chunks or needing any imports
 */
declare function bundleMinimalFilesCss(ctx: PandaContext, outfile: string): Promise<{
    files: string[];
    msg: string;
}>;
type CssArtifactType = 'preflight' | 'tokens' | 'static' | 'global' | 'keyframes';
/**
 * Generates the CSS for a given artifact type
 */
declare function generateCssArtifactOfType(ctx: PandaContext, cssType: CssArtifactType, outfile: string): Promise<{
    msg: string;
}>;

declare function generate(config: Config, configPath?: string): Promise<void>;

declare function setupGitIgnore(ctx: PandaContext): void;

declare function parseDependency(fileOrGlob: string): Message | null;

type SetupOptions = Partial<Config> & {
    force?: boolean;
};
declare function setupConfig(cwd: string, opts?: SetupOptions): Promise<void>;
declare function setupPostcss(cwd: string): Promise<void>;

declare function shipFiles(ctx: PandaContext, outfile: string): Promise<void>;

export { Builder, CssArtifactType, PandaContext, analyzeTokens, bundleCss, bundleMinimalFilesCss, createContext, debugFiles, emitArtfifactsAndCssChunks, emitArtifacts, execCommand, extractFile, findConfig, generate, generateCssArtifactOfType, loadConfigAndCreateContext, parseDependency, setupConfig, setupGitIgnore, setupPostcss, shipFiles, writeAnalyzeJSON, writeAndBundleCssChunks };
